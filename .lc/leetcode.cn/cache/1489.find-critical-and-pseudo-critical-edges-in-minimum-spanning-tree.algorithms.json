{"id":1613,"fid":"1489","name":"找到最小生成树里的关键边和伪关键边","slug":"find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree","link":"https://leetcode.cn/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/description/","percent":66.79121433981318,"level":"Hard","category":"algorithms","totalAC":"13.2K","totalSubmit":"19.9K","likes":137,"dislikes":0,"desc":"<p>给你一个 <code>n</code>&nbsp;个点的带权无向连通图，节点编号为 <code>0</code>&nbsp;到 <code>n-1</code>&nbsp;，同时还有一个数组 <code>edges</code>&nbsp;，其中 <code>edges[i] = [from</code><code><sub>i</sub>, to<sub>i</sub>, weight<sub>i</sub>]</code>&nbsp;表示在&nbsp;<code>from<sub>i</sub></code>&nbsp;和&nbsp;<code>to<sub>i</sub></code>&nbsp;节点之间有一条带权无向边。最小生成树&nbsp;(MST) 是给定图中边的一个子集，它连接了所有节点且没有环，而且这些边的权值和最小。</p>\n\n<p>请你找到给定图中最小生成树的所有关键边和伪关键边。如果从图中删去某条边，会导致最小生成树的权值和增加，那么我们就说它是一条关键边。伪关键边则是可能会出现在某些最小生成树中但不会出现在所有最小生成树中的边。</p>\n\n<p>请注意，你可以分别以任意顺序返回关键边的下标和伪关键边的下标。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/21/ex1.png\" style=\"height: 262px; width: 259px;\"></p>\n\n<pre><strong>输入：</strong>n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]\n<strong>输出：</strong>[[0,1],[2,3,4,5]]\n<strong>解释：</strong>上图描述了给定图。\n下图是所有的最小生成树。\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/21/msts.png\" style=\"height: 553px; width: 540px;\">\n注意到第 0 条边和第 1 条边出现在了所有最小生成树中，所以它们是关键边，我们将这两个下标作为输出的第一个列表。\n边 2，3，4 和 5 是所有 MST 的剩余边，所以它们是伪关键边。我们将它们作为输出的第二个列表。\n</pre>\n\n<p><strong>示例 2 ：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/21/ex2.png\" style=\"height: 253px; width: 247px;\"></p>\n\n<pre><strong>输入：</strong>n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]]\n<strong>输出：</strong>[[],[0,1,2,3]]\n<strong>解释：</strong>可以观察到 4 条边都有相同的权值，任选它们中的 3 条可以形成一棵 MST 。所以 4 条边都是伪关键边。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= edges.length &lt;= min(200, n * (n - 1) / 2)</code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>0 &lt;= from<sub>i</sub> &lt; to<sub>i</sub> &lt; n</code></li>\n\t<li><code>1 &lt;= weight<sub>i</sub>&nbsp;&lt;= 1000</code></li>\n\t<li>所有 <code>(from<sub>i</sub>, to<sub>i</sub>)</code>&nbsp;数对都是互不相同的。</li>\n</ul>\n","templates":[{"value":"cpp","text":"C++","defaultCode":"class Solution {\npublic:\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\n\n    }\n};"},{"value":"java","text":"Java","defaultCode":"class Solution {\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\n\n    }\n}"},{"value":"python","text":"Python","defaultCode":"class Solution(object):\n    def findCriticalAndPseudoCriticalEdges(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\""},{"value":"python3","text":"Python3","defaultCode":"class Solution:\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:"},{"value":"c","text":"C","defaultCode":"\n\n/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** findCriticalAndPseudoCriticalEdges(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize, int** returnColumnSizes){\n\n}"},{"value":"csharp","text":"C#","defaultCode":"public class Solution {\n    public IList<IList<int>> FindCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\n\n    }\n}"},{"value":"javascript","text":"JavaScript","defaultCode":"/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {number[][]}\n */\nvar findCriticalAndPseudoCriticalEdges = function(n, edges) {\n\n};"},{"value":"ruby","text":"Ruby","defaultCode":"# @param {Integer} n\n# @param {Integer[][]} edges\n# @return {Integer[][]}\ndef find_critical_and_pseudo_critical_edges(n, edges)\n\nend"},{"value":"swift","text":"Swift","defaultCode":"class Solution {\n    func findCriticalAndPseudoCriticalEdges(_ n: Int, _ edges: [[Int]]) -> [[Int]] {\n\n    }\n}"},{"value":"golang","text":"Go","defaultCode":"func findCriticalAndPseudoCriticalEdges(n int, edges [][]int) [][]int {\n\n}"},{"value":"scala","text":"Scala","defaultCode":"object Solution {\n    def findCriticalAndPseudoCriticalEdges(n: Int, edges: Array[Array[Int]]): List[List[Int]] = {\n\n    }\n}"},{"value":"kotlin","text":"Kotlin","defaultCode":"class Solution {\n    fun findCriticalAndPseudoCriticalEdges(n: Int, edges: Array<IntArray>): List<List<Int>> {\n\n    }\n}"},{"value":"rust","text":"Rust","defaultCode":"impl Solution {\n    pub fn find_critical_and_pseudo_critical_edges(n: i32, edges: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n\n    }\n}"},{"value":"php","text":"PHP","defaultCode":"class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $edges\n     * @return Integer[][]\n     */\n    function findCriticalAndPseudoCriticalEdges($n, $edges) {\n\n    }\n}"},{"value":"typescript","text":"TypeScript","defaultCode":"function findCriticalAndPseudoCriticalEdges(n: number, edges: number[][]): number[][] {\n\n};"},{"value":"racket","text":"Racket","defaultCode":"(define/contract (find-critical-and-pseudo-critical-edges n edges)\n  (-> exact-integer? (listof (listof exact-integer?)) (listof (listof exact-integer?)))\n\n  )"},{"value":"erlang","text":"Erlang","defaultCode":"-spec find_critical_and_pseudo_critical_edges(N :: integer(), Edges :: [[integer()]]) -> [[integer()]].\nfind_critical_and_pseudo_critical_edges(N, Edges) ->\n  ."},{"value":"elixir","text":"Elixir","defaultCode":"defmodule Solution do\n  @spec find_critical_and_pseudo_critical_edges(n :: integer, edges :: [[integer]]) :: [[integer]]\n  def find_critical_and_pseudo_critical_edges(n, edges) do\n\n  end\nend"},{"value":"dart","text":"Dart","defaultCode":"class Solution {\n  List<List<int>> findCriticalAndPseudoCriticalEdges(int n, List<List<int>> edges) {\n\n  }\n}"}],"testcase":"5\n[[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]","testable":true,"templateMeta":{"name":"findCriticalAndPseudoCriticalEdges","params":[{"name":"n","type":"integer"},{"type":"integer[][]","name":"edges"}],"return":{"type":"list<list<integer>>"}}}